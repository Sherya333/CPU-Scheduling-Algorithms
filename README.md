# CPU-Scheduling-Algorithms
The project explains and simulates different CPU Scheduling Algorithms that decide the order of process execution. Users can see how processes are scheduled and compare their performance based on waiting time and turnaround time. It covers FCFS , SJF, SRTF , RR with solution

This is a **web-based academic project** that demonstrates concepts of software engineering and operating systems.  
It contains multiple interconnected web pages: a **login system**, **CPU scheduling algorithms**, **waterfall model**, **graphs**, and a **solution page**.  
The project is built using **HTML, CSS, and JavaScript**.

---

## 🔑 Login Page
- The project begins with a **login system** (`login.html` + `login.css` + `login.js`).  
- Users must log in to access the rest of the project.  
- **Credentials to log in:**  
  - **Username:** `user`  
  - **Password:** `password`  

If incorrect credentials are entered, an alert is displayed.

---

## ⚙️ CPU Scheduling Algorithms
- Implemented in **`algorithm.html` + `algorithm.css`**.  
- Explains various **CPU scheduling techniques** with examples.  
- Algorithms included:  
  - **First Come First Serve (FCFS)**  
  - **Shortest Job Next (SJN)**  
  - **Round Robin (RR)**  
  - **Priority Scheduling**  

Each algorithm is visually presented with interactive styles to make learning easier.

---

## 🏗️ Waterfall Model
- Implemented in **`waterfall.html` + `waterfall.css` + `waterfall.js`**.  
- Explains the **Waterfall Model of Software Development**.  
- Covers different phases:  
  - Requirement Analysis  
  - System Design  
  - Implementation  
  - Testing  
  - Deployment  
  - Maintenance  

The model is explained with step-by-step visual representation.

---

## 📊 Graphs
- Graphs are used to visualize CPU scheduling algorithm performance and results.  
- Implemented in the **simulator** and **solution** sections.  
- Helps compare different algorithms based on waiting time, turnaround time, and efficiency.

---

## ✅ Solution Page
- Implemented in **`solution.html`**.  
- Displays the **final results** after running the scheduling simulations.  
- Provides a clear comparison of algorithms and their performance metrics.  

---

## 🛠️ Technologies Used
- **HTML5** – Page structure  
- **CSS3** – Styling and layout  
- **JavaScript** – Interactivity, login validation, and simulation logic  

---

## 🚀 How to Run
1. Download or clone the repository.  
2. Extract the files if downloaded as `.zip`.  
3. Open **`login.html`** in your browser.  
4. Enter credentials:  
   - Username → `user`  
   - Password → `password`  
5. Once logged in, navigate through:  
   - `algorithm.html` → CPU scheduling algorithms  
   - `waterfall.html` → Waterfall model explanation  
   - `simulator.html` → Simulation of algorithms  
   - `solution.html` → Final results and graphs  

---

## 📂 Project Structure
# Final PBL Project

This is a **web-based academic project** that demonstrates concepts of software engineering and operating systems.  
It contains multiple interconnected web pages: a **login system**, **CPU scheduling algorithms**, **waterfall model**, **graphs**, and a **solution page**.  
The project is built using **HTML, CSS, and JavaScript**.

---

## 🔑 Login Page
- The project begins with a **login system** (`login.html` + `login.css` + `login.js`).  
- Users must log in to access the rest of the project.  
- **Credentials to log in:**  
  - **Username:** `user`  
  - **Password:** `password`  

If incorrect credentials are entered, an alert is displayed.

---

## ⚙️ CPU Scheduling Algorithms
- Implemented in **`algorithm.html` + `algorithm.css`**.  
- Explains various **CPU scheduling techniques** with examples.  
- Algorithms included:  
  - **First Come First Serve (FCFS)**  
  - **Shortest Job Next (SJN)**  
  - **Round Robin (RR)**  
  - **Priority Scheduling**  

Each algorithm is visually presented with interactive styles to make learning easier.

---

## 🏗️ Waterfall Model
- Implemented in **`waterfall.html` + `waterfall.css` + `waterfall.js`**.  
- Explains the **Waterfall Model of Software Development**.  
- Covers different phases:  
  - Requirement Analysis  
  - System Design  
  - Implementation  
  - Testing  
  - Deployment  
  - Maintenance  

The model is explained with step-by-step visual representation.

---

## 📊 Graphs
- Graphs are used to visualize CPU scheduling algorithm performance and results.  
- Implemented in the **simulator** and **solution** sections.  
- Helps compare different algorithms based on waiting time, turnaround time, and efficiency.

---

## ✅ Solution Page
- Implemented in **`solution.html`**.  
- Displays the **final results** after running the scheduling simulations.  
- Provides a clear comparison of algorithms and their performance metrics.  

---

## 🛠️ Technologies Used
- **HTML5** – Page structure  
- **CSS3** – Styling and layout  
- **JavaScript** – Interactivity, login validation, and simulation logic  

---

## 🚀 How to Run
1. Download or clone the repository.  
2. Extract the files if downloaded as `.zip`.  
3. Open **`login.html`** in your browser.  
4. Enter credentials:  
   - Username → `user`  
   - Password → `password`  
5. Once logged in, navigate through:  
   - `algorithm.html` → CPU scheduling algorithms  
   - `waterfall.html` → Waterfall model explanation  
   - `simulator.html` → Simulation of algorithms  
   - `solution.html` → Final results and graphs  

---

## 📂 Project Structure
CPU Scheduling Algorithms/
│── login.html # Login page
│── login.css # Login page styling
│── login.js # Login validation (username=user, password=password)
│── index.html # Entry / landing page
│── algorithm.html # CPU scheduling explanation
│── algorithm.css # Styling for algorithm page
│── simulator.html # Graphs & simulation page
│── solution.html # Final solution/results page
│── waterfall.html # Waterfall model page
│── waterfall.css # Styling for waterfall page
│── waterfall.js # Interactivity for waterfall model
│── script.js # General script logic
│── style.css # General styles



---

This project is a **complete academic demonstration** of operating system scheduling algorithms, software engineering models, and their visualization.
